# TDesign Vue Next Backend

基于 Spring Boot + MySQL + Redis 的后端 API 服务，为 TDesign Vue Next 前端项目提供完整的后端支持。

## 技术栈

- **Spring Boot 3.2.0** - 主框架
- **Spring Security** - 安全框架
- **MyBatis Plus** - ORM框架
- **MySQL 8.0** - 数据库
- **Redis** - 缓存
- **JWT** - 身份认证
- **Druid** - 数据库连接池
- **Hutool** - 工具类库

## 功能特性

- ✅ 用户认证（登录/注册）
- ✅ JWT Token 认证
- ✅ 基于角色的权限控制（RBAC）
- ✅ 动态路由菜单
- ✅ 跨域支持
- ✅ 全局异常处理
- ✅ 参数校验
- ✅ 逻辑删除

## 快速开始

### 1. 环境要求

- JDK 17+
- MySQL 8.0+
- Redis 6.0+
- Maven 3.6+

### 2. 数据库初始化

1. 创建数据库：
```sql
CREATE DATABASE tdesign_db DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

2. 执行初始化脚本：
```bash
mysql -u root -p tdesign_db < database/schema.sql
```

### 3. 配置修改

修改 `src/main/resources/application.yml` 中的数据库和Redis配置：

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/tdesign_db?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8
    username: your_username
    password: your_password
  
  data:
    redis:
      host: localhost
      port: 6379
      password: your_redis_password
```

### 4. 启动项目

```bash
# 编译项目
mvn clean compile

# 启动项目
mvn spring-boot:run
```

项目启动后，API服务将在 `http://localhost:8080/api` 运行。

## API 接口

### 认证接口

#### 用户登录
```
POST /api/auth/login
Content-Type: application/json

{
  "username": "admin",
  "password": "123456"
}
```

#### 用户注册
```
POST /api/auth/register
Content-Type: application/json

{
  "username": "newuser",
  "password": "123456",
  "confirmPassword": "123456",
  "nickname": "新用户",
  "email": "user@example.com"
}
```

### 用户接口

#### 获取用户信息
```
GET /api/user/info
Authorization: Bearer {token}
```

#### 获取用户菜单
```
GET /api/user/menus
Authorization: Bearer {token}
```

### 权限接口

#### 获取菜单列表（前端路由）
```
GET /api/get-menu-list-i18n
Authorization: Bearer {token}
```

## 数据库设计

### 核心表结构

1. **sys_user** - 用户表
2. **sys_role** - 角色表
3. **sys_permission** - 权限表
4. **sys_user_role** - 用户角色关联表
5. **sys_role_permission** - 角色权限关联表

### 初始数据

- 超级管理员：`admin` / `123456`
- 普通用户：`user` / `123456`

## 权限控制

### 角色权限

- **SUPER_ADMIN** - 超级管理员，拥有所有权限
- **USER** - 普通用户，拥有部分基础权限

### 权限类型

- **1** - 菜单权限
- **2** - 按钮权限
- **3** - 接口权限

## 前端集成

### 1. 修改前端API配置

在前端项目的 `src/utils/request/index.ts` 中修改API基础路径：

```typescript
const baseURL = 'http://localhost:8080/api';
```

### 2. 修改登录接口

在前端项目的 `src/store/modules/user.ts` 中修改登录逻辑：

```typescript
async login(userInfo: Record<string, unknown>) {
  const res = await request.post('/auth/login', userInfo);
  if (res.code === 200) {
    this.token = res.data.token;
  } else {
    throw res;
  }
}
```

### 3. 修改菜单接口

在前端项目的 `src/api/permission.ts` 中修改菜单接口：

```typescript
export function getMenuList() {
  return request.get<MenuListResult>({
    url: '/get-menu-list-i18n',
  });
}
```

## 部署说明

### 开发环境

```bash
mvn spring-boot:run
```

### 生产环境

```bash
# 打包
mvn clean package -Dmaven.test.skip=true

# 运行
java -jar target/tdesign-backend-1.0.0.jar
```

## 注意事项

1. 确保MySQL和Redis服务正常运行
2. 首次运行需要执行数据库初始化脚本
3. 生产环境请修改JWT密钥和数据库密码
4. 建议配置HTTPS以提高安全性

## 许可证

MIT License 

1、Java语言
    1.1、Java基础

      一、为什么Java可以实现一次编写、到处运行
        JVM（Java虚拟机）是Java跨平台的关键。
        在程序运行前，Java源代码（.java）需要编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。同一份Java源代码在不同的平台上运行，不需要做任何改变只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，他能将统一的字节码翻译成该平台的机器码。

        注意事项：
        1、编译后生成的是字节码不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。
        2、跨平台的是Java程序，而不是JVM，JVM是C\C++开发的软件，不同平台下需要安装不同版本的JVM。


      二、一个java文件里面可以有多个类吗（不含内部类）？
        一个java文件里可以有多个类，但最多只能有一个被public修饰的类，如果这个类包含被public修饰的类，则这个类的名称必须与java文件名一致

      三、Java的访问权限
        Java语言为我们提供了三种访问修饰符，即private、protected、public,在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即private、default、protected、public，在不加任何修饰符时为default访问权限。在修饰成员变量/成员方法时，该成员的四种访问权限的含义如下：
        private：该成员可以被该类内部成员访问
        default：该成员可以被该类内部成员访问、也可以被同一包下的其他类访问
        protected：该成员可以被该类内部成员访问、也可以被同一包下的其他类访问、还可以被其子类访问
        public：该成员可以被任意包下任意类访问

        在修饰类时，该类只有两种访问权限，对应的访问权限含义如下：
        default：该类可以被同一包下的其他类访问
        public：该类可以被任意包下任意类访问

      四、介绍Java的数据类型
        基本数据类型有8个，可以分为4个小类，分别是整数类型（byte/short/int/long）、浮点类型（float/double）、字符类型（char）、布尔类型（boolean）,这八个基本数据类型中，除了boolean以外，其他七种类型可以相互转换。
        引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、对象、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。
        对于基本数据类型，下面是每种类型所占用的内存空间：
        byte: 1字节（8位），  数据范围是-2^7~~~2^7-1
        short: 2字节（16位），数据范围是-2^15~~~2^15-1
        int: 4字节（32位），  数据范围是-2^31~~~2^31-1
        long: 8字节（64位）， 数据范围是-2^63~~~2^63-1
        float：4字节（32位），数据范围大约是-3.4*10^38~~~3.4*10^38  精度7位十进制有效数字
        double：8字节（64位），数据范围大约是-1.8*10^308~~~1.8*10^308  精度15~16位十进制有效数字
        boolean：Java规范没有规定boolean占用多少字节，在实际 JVM 实现中，单个 boolean 变量通常会被当作 1 个字节（8 位）来存储，因为计算机的最小寻址单位是字节（byte）

      五、局部变量和成员变量的区别
        成员变量：
        成员变量是在类的范围里定义的变量
        成员变量有默认的初始值
        未被static修饰的成员变量也叫实例变量，存储于对象所在的堆内存中，生命周期与对象相同
        被static修饰的成员变量也叫类变量，存储于方法区中，生命周期与当前类相同
        局部变量：
        局部变量是在方法里定义的变量
        局部变量没有默认值必须显示赋值
        存储于栈内存中，作用范围结束，变量空间自动释放

      六、为什么要有包装类
        Java语言是面向对象语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java为每个基本数据类型都定义了一个引用类型，这就是包装类。

      七、自动装箱、自动拆箱的应用场景
        自动装箱、自动拆箱是JDK1.5提供的功能，自动装箱可以把一个基本数据类型的值直接赋值给包装类型，自动拆箱可以把一个包装类型的对象直接赋值给对应的基本类型，自动装箱拆箱可以大大简化基本类型变量和包装类型之间的转换过程

      八、如何对Integer和Double类型判断相等
        先转换为相同的数据类型，再进行==比较

      九、int和Integer有什么区别，二者在做==运算会得到什么结果
        int是基本数据类型，Integer是int的包装类。二者在做==运算时，Integer会自动拆箱成int类型，如果两个int值相等则返回true

      十、什么是面向对象
        面相对象是一种更优秀的程序设计方法，基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观存在的事物触发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物本身的特点，把它们抽象的表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映象到客观世界，并保持客观世界中事物及其相互关系的本来面貌。

        拓展：结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。因为结构化设计方法主张按功能把软件体统逐步细分，因此这种方法也被称为面向功能的程序设计方法，结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都能接受一些数据，处理完后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。
        每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包含函数的返回值以及传出参数等。结构化程序设计有两个局限性：
          1、设计不够直观，与人类思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。
          2、适应性差、可拓展性不强。由于结构化采用自顶向下的设计方式，所以当用户的需求发生改变，或者需要修改现有的实现方式时，都需要自顶向下修改模块结构，这种方式维护成本相当高。

      十一、面向对象三大特征
        面向对象程序设计方法具有三个基本特征：封装、继承、多态。其中封装是指将对象实现细节隐藏通过一些公共方法来暴漏该对象的一些功能；继承是面向对象实现软件复用的一种重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；多态是指子类对象可以直接赋值给父类变量，但运行时依然是子类的特征，这意味着同一个对象在执行同一个方法时，可能表现出多种行为特征。

        拓展1：多态中子类是一种特殊的父类，Java允许把一个子类对象直接赋值给一个父类引用变量，无需任何类型转换，或者被称为向上转型，向上转型由系统自动完成。当把一个子类对象直接赋值给父类引用变量时，运行该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就会出现，相同类型的变量调用同一个方法表现出不同的行为特征，这就是多态。
        
        拓展2：抽象也是面向对象的重要部分，抽象就是忽略主题中与当前目标无关的那些方面，以便充分注意与目标有关的方面。抽象并不打算了解全部的问题，而是只考虑部分问题。

      十二、封装的目的是什么，为什么要有封装
        封装是面向对象对客观世界的模拟，在客观世界里，对象的状态信息都隐藏在对象内部，外界无法直接修改和操作。对一个类或对象实现良好的封装，可以实现以下目的：
          1、隐藏类的实现细节
          2、让使用者只能通过预先设定的方法来访问数据，从而可以在方法里加入控制逻辑，限制对成员变量的不合理访问
          3、可以进行数据检查，从而有利于保护对象信息的完整性
          4、便于修改，提高代码的可维护性
        为了实现良好的封装，需要从两个方面考虑：
          1、将成员变量和实现细节隐藏起来，不允许外部直接访问
          2、将方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作
        封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来，这两个都靠Java提供的访问控制符来实现。

      十三、Object中都有哪些方法
        1、Class<?> getClass():返回该对象的运行时类
        2、boolean equals(Object obj):判断指定对象与该对象是否相等
        3、int hashCode():返回该对象的hashCode。默认情况下，该对象的hashCode都是根据地址来计算，但很多类重写了hashCode()方法。
        4、String toString():返回该对象的字符串表示，Object的toString()返回运行时类名@十六进制hashCode值，但很多类重写了toString()方法，用于返回表示该对象信息的字符串。
        5、wait()：使当前线程进入等待状态
        6、notify()：唤醒在此对象监视器上等待的单个线程，如果多个线程在等待，选择哪个线程被唤醒是不确定的，有可能导致某些线程永远等待
        7、notifyAll():如果多个线程在等待，选择哪个线程被唤醒是不确定的
        8、clone():自我克隆，只能被子类重写或调用
        9、finalize():垃圾回收，针对一个对象，垃圾回收期只会调用finalize()一次，finalize()是否调用何时调用不确定，我们也不要主动调用。从JDK9开始标记不推荐使用的方法。

      十四、hashCode()和equals()的关系
        hashCode()用于获取哈希码（散列码），equals()用于比较两个对象是否相等，它们遵守如下规定：如果两个对象相等，它们必须有相同的哈希码，如果两个对象有相同的哈希码，则它们不一定相等
        拓展：当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。

      十五、为什么要重写equals()和hashCode()
        Object类提供的equals()方法默认是用==来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中equals()方法的默认实现是没有实用价值的，所以通常都要重写。由于hashCode()与equals()具有联动关系（参考“说一说hashCode()和equals()的关系”一题），所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。

      十六、==运算符和equals()的区别
        ==运算符：
        作用于基本数据类型时，是比较两个数值是否相等
        作用于引用数据类型时，是比较两个对象的内存地址是否相同，即判断它们是否为同一个对象
        equals()方法：
        没有重写时，Object默认以 == 来实现，即比较两个对象的内存地址是否相同；
        进行重写后，一般会按照对象的内容来进行比较，若两个对象内容相同则认为对象相等，否则认为对象不等。

      十七、String、StringBuffer 与 StringBuilder 的区别
        String：不可变（immutable）任何修改操作都会创建新对象，性能最慢（频繁创建新对象）
        StringBuffer：可变（mutable）线程安全（方法使用 synchronized 修饰），性能中等（同步开销）
        StringBuilder：可变（mutable）非线程安全，性能最快（无同步开销）

      十八、使用字符串时""和new推荐哪个
        先看看""和new String("")的区别：
        当Java程序直接使用"" 的字符串直接量时，JVM将会使用常量池来管理这个字符串
        当使用new String("")时，JVM会先使用常量池来管理"" 直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。
        显然，采用new的方式会多创建一个对象出来，会占用更多的内存，所以一般建议使用直接量的方式创建字符串。

      十九、接口和抽象类有哪些区别
        从设计目的上来说，二者有如下的区别：
        接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。
        抽象类体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。

      二十、接口中可以有构造函数吗
        接口定义的是一种规范，因此接口中不能包含构造器和初始化块定义，接口中可以包含成员变量（只能是静态常量）、方法（抽象方法、类方法、默认方法和私有方法）、内部类（包括内部接口、枚举）定义。

      二十一、Java的异常机制
        在Java中处理异常语句通常由try、catch、finally三部分组成。其中try包裹业务代码，catch用于捕获和处理某个类型的异常，finally则用于回收资源。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally中关闭这些资源，无论是否发生异常，finally块一定会执行。
        关于抛出异常：当程序出现错误时，系统会自动抛出异常。Java也允许程序主动抛出异常。当业务代码中，判断某项错误条件成立时，可以使用throw关键字向外抛出异常。如果当前方法不知道如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常交给JVM处理。

      二十二、Java的异常接口
        Throwable是异常的顶层父类，代表所有非正常的情况。它有两个直接子类，分别是Error和Exception。
        Error是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错误，因此程序不应该试图使用catch块来捕获Error对象。在定义方法时，也无需在其throw子句中声明该方法可能抛出Error及其任何子类。
        Exception是异常,他被分为两大类，分别是Checked异常和Runtime异常。所有的RuntimeException及其子类的实例被称为运行时异常，不是RuntimeException及其子类的实例则被称为Checked异常。Java认为所有Checked都是可以被处理（修复）的异常，所以Java必须显示处理Checked异常。如果程序没有处理Checked异常，那么该程序在编译的时候就会发生错误，无法通过编译。Runtime异常则更加灵活，Runtime无需显示声明抛出，如果程序需要捕获Runtime异常，也可以用try...catch块来实现。

      二十三、static 和 final 的区别
        static关键字可以修饰成员变量、成员方法、初始化块、内部类，被static修饰的成员是类的成员，它属于类、不属于单个对象。以下是static修饰这4种成员时表现出的特征：
        类变量：被static修饰的成员变量叫类变量（静态变量）。类变量属于类，它随类的信息存储在方法区，并不随对象存储在堆中，类变量可以通过类名来访问，也可以通过对象名来访问，但建议通过类名访问它。
        类方法：被static修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，建议通过类名访问它。
        静态块：被static修饰的初始化块叫静态初始化块。静态块属于类，它在类加载的时候被隐式调用一次，之后便不会被调用了。
        静态内部类：被static修饰的内部类叫静态内部类。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。
        final关键字可以修饰类、方法、变量，以下是final修饰这3种目标时表现出的特征：
        final类：final关键字修饰的类不可以被继承。
        final方法：final关键字修饰的方法不可以被重写。
        final变量：final关键字修饰的变量，一旦获得了初始值，就不可以被修改。

      二十四、Java泛型
        Java集合有个缺点把一个对象丢进集合里之后，集合就会忘记这个对象的类型，当再次取出这个对象时，该对象的编译类型就变成了Object类型（运行时类型没变）。Java集合之所以被设计成这样，是因为集合的设计者不知道我们会用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样带来两个问题：
        1、集合对元素类型没有任何限制，这样可能会引发一些问题，例如像创建一个只保存Dog类型的集合，但程序可以将Cat扔进去，可能会引发异常。
        2、把对象丢进集合时，集合失去了对象的状态信息，只知道装的是Object，取出集合元素是通常还需要进行强制类型转换，这种强制类型转换既增加了编程的复杂度，又可能会引发ClassCastException(类转换异常)。
        从Java5开始，Java引入了参数化类型的概念，允许集合在创建时指定集合元素的类型，Java的参数化类型被称为泛型。有了泛型以后，程序再也不能“不小心”地把其他对象“丢进”集合中。而且程序更加简洁，集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。
        
      二十五、Java的反射机制
        Java程序中的对象在运行时可以表现为两种类型，即编译时类型和运行时类型。例如 Person p = new Student(); ，这行代码将会生成一个p变量，该变量的编译时类型为Person，运行时类型为Student。有时，程序在运行时接收到外部传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，而解决这个问题有以下两种做法：
        第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用instanceof运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。
        第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。
        具体来说，通过反射机制，我们可以实现如下的操作：
        程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的信息
        程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员
        程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象

      二十六、Java的四种引用方式
        强引用：这是Java程序中最常见的引用方式，即程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。
        软引用：当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象。当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。
        弱引用：弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。
        虚引用：虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。

          
    1.2、集合类
      一、Java中都有哪些容器（集合类）
        Java中的集合主要由Collection和Map这两个接口派生而出，其中Collection接口又派生出三个子接口，分别是Set、List、Queue。所有Java集合类都是set、List、Queue、Map这四个接口的实现类，这四个接口将集合分成了四大类:
          1、Set代表无序元素不可重复的集合
          2、List代表有序的，元素可以重复的集合
          3、Queue代表先进先出的队列
          4、Map代表具有映射关系（key-value）的集合
        这些接口拥有众多实现类，最常用的又HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。
      二、Java集合中线程安全和线程不安全的分别有哪些
        java.util包下大部分集合都是


    1.3、IO


    1.4、多线程


    1.5、JVM



2、数据库
    2.1、SQL


    2.2、索性


    2.3、事务


    2.4、锁


    2.5、优化


    2.6、其他

3、web开发
    3.1、spring boot


    3.2、spring 


    3.3、spring MVC


    3.4、MyBatis


    3.5、其他

4、中间件
    4.1、redis


    4.2、消息队列


    4.3、搜索引擎



5、算法与数据结构
    5.1、树
    5.2、堆与栈
    5.3、数组
    5.4、排序
    5.5、哈希
    5.6、动态规划
    5.7、链表
    5.8、字符串
    5.9、高级算法

6、分布式

7、操作系统

8、计算机网络

9、设计模式

10、场景应用