# Java基础

## 1.1 为什么Java代码可以实现一次编写、到处运行?
### 参考答案
JVM（Java虚拟机）是Java跨平台的关键。  
在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。

### 注意事项
1. 编译的结果是生成字节码、不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行；
2. 跨平台的是Java程序、而不是JVM，JVM是用C/C++开发的软件，不同平台下需要安装不同版本的JVM。

## 1.2 一个Java文件里可以有多个类吗（不含内部类）?
### 参考答案
1. 一个java文件里可以有多个类，但最多只能有一个被public修饰的类；
2. 如果这个java文件中包含public修饰的类，则这个类的名称必须和java文件名一致。

## 1.3 说一说你对Java访问权限的了解
### 参考答案
Java语言为我们提供了三种访问修饰符，即private、protected、public，在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即private、default、protected、public，注意在不加任何修饰符时为default访问权限。

在修饰成员变量/成员方法时，该成员的四种访问权限的含义如下：
- private：该成员可以被该类内部成员访问；
- default：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问；
- protected：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问，还可以被它的子类访问；
- public：该成员可以被任意包下，任意类的成员进行访问。

在修饰类时，该类只有两种访问权限，对应的访问权限的含义如下：
- default：该类可以被同一包下其他的类访问；
- public：该类可以被任意包下，任意的类所访问。

## 1.4 介绍一下Java的数据类型
### 参考答案
Java数据类型包括基本数据类型和引用数据类型两大类。

基本数据类型有8个，可以分为4个小类，分别是整数类型（byte/short/int/long）、浮点类型（float/double）、字符类型（char）、布尔类型（boolean）。其中，4个整数类型中，int类型最为常用。2个浮点类型中，double最为常用。另外，在这8个基本类型当中，除了布尔类型之外的其他7个类型，都可以看做是数字类型，它们相互之间可以进行类型转换。

引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。

### 扩展阅读
对于基本数据类型，你需要了解每种类型所占据的内存空间，面试官可能会追问这类问题：
- byte：1字节（8位），数据范围是-2^7 ~ 2^7-1；
- short：2字节（16位），数据范围是-2^15 ~ 2^15-1；
- int：4字节（32位），数据范围是-2^31 ~ 2^31-1；
- long：8字节（64位），数据范围是-2^63 ~ 2^63-1；
- float：4字节（32位），数据范围大约是-3.4*10^38 ~ 3.4*10^38；
- double：8字节（64位），数据范围大约是-1.8*10^308 ~ 1.8*10^308；
- char：2字节（16位），数据范围是\u0000 ~ \uffff；
- boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。

对于引用数据类型，你需要了解JVM的内存分布情况，知道引用以及引用对象存放的位置，详见JVM部分的题目。

## 1.5 int类型的数据范围是多少?
### 参考答案
int类型占4字节（32位），数据范围是-2^31 ~ 2^31-1。

## 1.6 请介绍全局变量和局部变量的区别
### 参考答案
Java中的变量分为成员变量和局部变量，它们的区别如下：

**成员变量：**
1. 成员变量是在类的范围里定义的变量；
2. 成员变量有默认初始值；
3. 未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；
4. 被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。

**局部变量：**
1. 局部变量是在方法里定义的变量；
2. 局部变量没有默认初始值；
3. 局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。

### 注意事项
Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。

## 1.7 请介绍一下实例变量的默认值
### 参考答案
实例变量若为引用数据类型，其默认值一律为null。若为基本数据类型，其默认值如下：
- byte：0；
- long：0L；
- float：0.0F；
- double：0.0；
- char：'\u0000'；
- boolean：false。

### 注意事项
上述默认值规则适用于所有的成员变量，所以对于类变量也是适用的。

## 1.8 为啥要有包装类?
### 参考答案
Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。

### 扩展阅读
Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。

## 1.9 说一说自动装箱、自动拆箱的应用场景
### 参考答案
自动装箱、自动拆箱是JDK1.5提供的功能。

自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；
自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型。

通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。

## 1.10 如何对Integer和Double类型判断相等?
### 参考答案
Integer、Double不能直接进行比较，这包括：
- 不能用==进行直接比较，因为它们是不同的数据类型；
- 不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等；
- 不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较。

整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用==进行比较。

示例代码：
```java
public class CompareDemo {
    public static void main(String[] args) {
        Integer i = 10;
        Double d = 10.0;
        System.out.println(i.doubleValue() == d.doubleValue());
    }
}
```

**1.11**
**int**和**Integer**有什么区别，⼆者在做**==**运算时会得到什么结果？

参考答案

int是基本数据类型，Integer是int的包装类。⼆者在做==运算时，Integer会⾃动拆箱为int类型，然后再进
⾏⽐较。届时，如果两个int值相等则返回true，否则就返回false。

**1.12** 说⼀说你对⾯向对象的理解

参考答案

⾯向对象是⼀种更优秀的程序设计⽅法，它的基本思想是使⽤类、对象、继承、封装、消息等基本概念
进⾏程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运⽤⼈类
的⾃然思维⽅式，强调直接以现实世界中的事物为中⼼来思考，认识问题，并根据这些事物的本质特
点，把它们抽象地表⽰为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像
到客观世界，并保持客观世界中事物及其相互关系的本来⾯貌。

扩展阅读

结构化程序设计⽅法主张按功能来分析系统需求，其主要原则可概括为⾃顶向下、逐步求精、模块化
等。结构化程序设计⾸先采⽤结构化分析⽅法对系统进⾏需求分析，然后使⽤结构化设计⽅法对系统进
⾏概要设计、详细设计，最后采⽤结构化编程⽅法来实现系统。

因为结构化程序设计⽅法主张按功能把软件系统逐步细分，因此这种⽅法也被称为⾯向功能的程序设计
⽅法；结构化程序设计的每个功能都负责对数据进⾏⼀次处理，每个功能都接受⼀些数据，处理完后输
出⼀些数据，这种处理⽅式也被称为⾯向数据流的处理⽅式。

结构化程序设计⾥最⼩的程序单元是函数，每个函数都负责完成⼀个功能，⽤以接收⼀些输⼊数据，函
数对这些输⼊数据进⾏处理，处理结束后输出⼀些数据。整个软件系统由⼀个个函数组成，其中作为程
序⼊⼝的函数被称为主函数，主函数依次调⽤其他普通函数，普通函数之间依次调⽤，从⽽完成整个软
件系统的功能。

每个函数都是具有输⼊、输出的⼦系统，函数的输⼊数据包括函数形参、全局变量和常量等，函数的输
出数据包括函数返回值以及传出参数等。结构化程序设计⽅式有如下两个局限性：

> 设计不够直观，与⼈类习惯思维不⼀致。采⽤结构化程序分析、设计时，开发者需要将客观世界模
> 型分解成⼀个个功能，每个功能⽤以完成⼀定的数据处理。
>
> 适应性差，可扩展性不强。由于结构化设计采⽤⾃顶向下的设计⽅式，所以当⽤⼾的需求发⽣改
> 变，或需要修改现有的实现⽅式时，都需要⾃顶向下地修改模块结构，这种⽅式的维护成本相当
> ⾼。

**1.13** ⾯向对象的三⼤特征是什么？

参考答案

⾯向对象的程序设计⽅法具有三个基本特征：封装、继承、多态。其中，封装指的是将对象的实现细节
隐藏起来，然后通过⼀些公⽤⽅法来暴露该对象的功能；继承是⾯向对象实现软件复⽤的重要⼿段，当
⼦类继承⽗类后，⼦类作为⼀种特殊的⽗类，将直接获得⽗类的属性和⽅法；多态指的是⼦类对象可以
直接赋给⽗类变量，但运⾏时依然表现出⼦类的⾏为特征，这意味着同⼀个类型的对象在执⾏同⼀个⽅
法时，可能表现出多种⾏为特征。

扩展阅读

抽象也是⾯向对象的重要部分，抽象就是忽略⼀个主题中与当前⽬标⽆关的那些⽅⾯，以便更充分地注
意与当前⽬标有关的⽅⾯。抽象并不打算了解全部问题，⽽只是考虑部分问题。例如，需要考察Person
对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分⾏为
特征，⽽这些数据、⾏为特征是软件系统所关⼼的部分。

**1.14** 封装的⽬的是什么，为什么要有封装？

参考答案

封装是⾯向对象编程语⾔对客观世界的模拟，在客观世界⾥，对象的状态信息都被隐藏在对象内部，外
界⽆法直接操作和修改。对⼀个类或对象实现良好的封装，可以实现以下⽬的：

> 隐藏类的实现细节；
>
> 让使⽤者只能通过事先预定的⽅法来访问数据，从⽽可以在该⽅法⾥加⼊控制逻辑，限制对成员变
> 量的不合理访问；
>
> 可进⾏数据检查，从⽽有利于保证对象信息的完整性；
>
> 便于修改，提⾼代码的可维护性。

扩展阅读

为了实现良好的封装，需要从两个⽅⾯考虑：

> 将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；
>
> 把⽅法暴露出来，让⽅法来控制对这些成员变量进⾏安全的访问和操作。

封装实际上有两个⽅⾯的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个⽅⾯都需要通过使
⽤Java提供的访问控制符来实现。

**1.15** 说⼀说你对多态的理解

参考答案

因为⼦类其实是⼀种特殊的⽗类，因此Java允许把⼀个⼦类对象直接赋给⼀个⽗类引⽤变量，⽆须任何
类型转换，或者被称为向上转型，向上转型由系统⾃动完成。

当把⼀个⼦类对象直接赋给⽗类引⽤变量时，例如 BaseClass obj = new
SubClass();，这个obj引⽤变量
的编译时类型是BaseClass，⽽运⾏时类型是SubClass，当运⾏时调⽤该引⽤变量的⽅法时，其⽅法⾏
为总是表现出⼦类⽅法的⾏为特征，⽽不是⽗类⽅法的⾏为特征，这就可能出现：相同类型的变量、调
⽤同⼀个⽅法时呈现出多种不同的⾏为特征，这就是多态。

扩展阅读

多态可以提⾼程序的可扩展性，在设计程序时让代码更加简洁⽽优雅。

例如我要设计⼀个司机类，他可以开轿⻋、巴⼠、卡⻋等等，⽰例代码如下：

> class Driver {
>
> void drive(Car car) { ... } void drive(Bus bus) { ... } void
> drive(Truck truck) { ... }
>
> }

在设计上述代码时，我已采⽤了重载机制，将⽅法名进⾏了统⼀。这样在进⾏调⽤时，⽆论要开什么交
通⼯具，都是通过driver.drive(obj)这样的⽅式来调⽤，对调⽤者⾜够的友好。

但对于程序的开发者来说，这显得繁琐，因为实际上这个司机可以驾驶更多的交通⼯具。当系统需要为
这个司机增加⻋型时，开发者就需要相应的增加driver⽅法，类似的代码会堆积的越来越多，显得臃肿。

采⽤多态的⽅式来设计上述程序，就会变得简洁很多。我们可以为所有的交通⼯具定义⼀个⽗类
Vehicle，然后按照如下的⽅式设计drive⽅法。调⽤时，我们可以传⼊Vehicle类型的实例，也可以传⼊任
意的Vehicle⼦类型的实例，对于调⽤者来说⼀样的⽅便，但对于开发者来说，代码却变得⼗分的简洁
了。

> class Driver {
>
> void drive(Vehicle vehicle) { ... } }

**1.16** **Java**中的多态是怎么实现的？

参考答案

多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为⽗类型。在调⽤程序时，则可以
根据实际情况，传⼊该⽗类型的某个⼦类型的实例，这样就实现了多态。对于⽗类型，可以有三种形
式，即普通的类、抽象类、接⼝。对于⼦类型，则要根据它⾃⾝的特征，重写⽗类的某些⽅法，或实现
抽象类/接⼝的某些抽象⽅法。

**1.17** **Java**为什么是单继承，为什么不能多继承？

参考答案

⾸先，Java是单继承的，指的是Java中⼀个类只能有⼀个直接的⽗类。Java不能多继承，则是说Java中
⼀个类不能直接继承多个⽗类。

其次，Java在设计时借鉴了C++的语法，⽽C++是⽀持多继承的。Java语⾔之所以摒弃了多继承的这项
特征，是因为多继承容易产⽣混淆。⽐如，两个⽗类中包含相同的⽅法时，⼦类在调⽤该⽅法或重写该
⽅法时就会迷惑。

准确来说，Java是可以实现"多继承"的。因为尽管⼀个类只能有⼀个直接⽗类，但是却可以有任意多个
间接的⽗类。这样的设计⽅式，避免了多继承时所产⽣的混淆。

**1.18** 说⼀说重写与重载的区别

参考答案

重载发⽣在同⼀个类中，若多个⽅法之间⽅法名相同、参数列表不同，则它们构成重载的关系。重载与
⽅法的返回值以及访问修饰符⽆关，即重载的⽅法不能根据返回类型进⾏区分。

重写发⽣在⽗类⼦类中，若⼦类⽅法想要和⽗类⽅法构成重写关系，则它的⽅法名、参数列表必须与⽗
类⽅法相同。另外，返回值要⼩于等于⽗类⽅法，抛出的异常要⼩于等于⽗类⽅法，访问修饰符则要⼤
于等于⽗类⽅法。还有，若⽗类⽅法的访问修饰符为private，则⼦类不能对其重写。

**1.19** 构造⽅法能不能重写？

参考答案

构造⽅法不能重写。因为构造⽅法需要和类保持同名，⽽重写的要求是⼦类⽅法要和⽗类⽅法保持同
名。如果允许重写构造⽅法的话，那么⼦类中将会存在与类名不同的构造⽅法，这与构造⽅法的要求是
⽭盾的。

**1.20** 介绍⼀下**Object**类中的⽅法

参考答案

Object类提供了如下⼏个常⽤⽅法：

> Class\<?\> getClass()：返回该对象的运⾏时类。
>
> boolean equals(Object obj)：判断指定对象与该对象是否相等。
>
> int
> hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()⽅法根据该对象
> 的地址来计算。但很多类都重写了Object类的hashCode()⽅法，不再根据地址来计算其hashCode()
> ⽅法值。
>
> String
> toString()：返回该对象的字符串表⽰，当程序使⽤System.out.println()⽅法输出⼀个对象，或
> 者把某个对象和字符串进⾏连接运算时，系统会⾃动调⽤该对象的toString()⽅法返回该对象的字符
> 串表⽰。Object类的toString()⽅法返回 运⾏时类名@⼗六进制hashCode值
> 格式的字符串，但很多类
> 都重写了Object类的toString()⽅法，⽤于返回可以表述该对象信息的字符串。

另外，Object类还提供了wait()、notify()、notifyAll()这⼏个⽅法，通过这⼏个⽅法可以控制线程的暂停和
运⾏。Object类还提供了⼀个clone()⽅法，该⽅法⽤于帮助其他对象来实现“⾃我克隆”，所谓“⾃我克隆”
就是得到⼀个当前对象的副本，⽽且⼆者之间完全隔离。由于该⽅法使⽤了protected修饰，因此它只能
被⼦类重写或调⽤。

扩展阅读

Object类还提供了⼀个finalize()⽅法，当系统中没有引⽤变量引⽤到该对象时，垃圾回收器调⽤此⽅法来
清理该对象的资源。并且，针对某⼀个对象，垃圾回收器最多只会调⽤它的finalize()⽅法⼀次。

注意，finalize()⽅法何时调⽤、是否调⽤都是不确定的，我们也不要主动调⽤finalize()⽅法。从JDK9开
始，这个⽅法被标记为不推荐使⽤的⽅法。